{"ts":1356729025003,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"var dust = {};\n\nfunction getGlobal(){\n  return (function(){\n    return this.dust;\n  }).call(null);\n}\n\n(function(dust) {\n\ndust.cache = {};\n\ndust.register = function(name, tmpl) {\n  if (!name) return;\n  dust.cache[name] = tmpl;\n};\n\ndust.render = function(name, context, callback) {\n  var chunk = new Stub(callback).head;\n  dust.load(name, chunk, Context.wrap(context)).end();\n};\n\ndust.stream = function(name, context) {\n  var stream = new Stream();\n  dust.nextTick(function() {\n    dust.load(name, stream.head, Context.wrap(context)).end();\n  });\n  return stream;\n};\n\ndust.renderSource = function(source, context, callback) {\n  return dust.compileFn(source)(context, callback);\n};\n\ndust.compileFn = function(source, name) {\n  var tmpl = dust.loadSource(dust.compile(source, name));\n  return function(context, callback) {\n    var master = callback ? new Stub(callback) : new Stream();\n    dust.nextTick(function() {\n      tmpl(master.head, Context.wrap(context)).end();\n    });\n    return master;\n  };\n};\n\ndust.load = function(name, chunk, context) {\n  var tmpl = dust.cache[name];\n  if (tmpl) {\n    return tmpl(chunk, context);\n  } else {\n    if (dust.onLoad) {\n      return chunk.map(function(chunk) {\n        dust.onLoad(name, function(err, src) {\n          if (err) return chunk.setError(err);\n          if (!dust.cache[name]) dust.loadSource(dust.compile(src, name));\n          dust.cache[name](chunk, context).end();\n        });\n      });\n    }\n    return chunk.setError(new Error(\"Template Not Found: \" + name));\n  }\n};\n\ndust.loadSource = function(source, path) {\n  return eval(source);\n};\n\nif (Array.isArray) {\n  dust.isArray = Array.isArray;\n} else {\n  dust.isArray = function(arr) {\n    return Object.prototype.toString.call(arr) == \"[object Array]\";\n  };\n}\n\ndust.nextTick = (function() {\n  if (typeof process !== \"undefined\") {\n    return process.nextTick;\n  } else {\n    return function(callback) {\n      setTimeout(callback,0);\n    };\n  }\n} )();\n\ndust.isEmpty = function(value) {\n  if (dust.isArray(value) && !value.length) return true;\n  if (value === 0) return false;\n  return (!value);\n};\n\n// apply the filter chain and return the output string\ndust.filter = function(string, auto, filters) {\n  if (filters) {\n    for (var i=0, len=filters.length; i<len; i++) {\n      var name = filters[i];\n      if (name === \"s\") {\n        auto = null;\n      }\n      // fail silently for invalid filters\n      else if (typeof dust.filters[name] === 'function') {\n        string = dust.filters[name](string);\n      }\n    }\n  }\n  // by default always apply the h filter, unless asked to unescape with |s\n  if (auto) {\n    string = dust.filters[auto](string);\n  }\n  return string;\n};\n\ndust.filters = {\n  h: function(value) { return dust.escapeHtml(value); },\n  j: function(value) { return dust.escapeJs(value); },\n  u: encodeURI,\n  uc: encodeURIComponent,\n  js: function(value) { if (!JSON) { return value; } return JSON.stringify(value); },\n  jp: function(value) { if (!JSON) { return value; } return JSON.parse(value); }\n};\n\nfunction Context(stack, global, blocks) {\n  this.stack  = stack;\n  this.global = global;\n  this.blocks = blocks;\n}\n\ndust.makeBase = function(global) {\n  return new Context(new Stack(), global);\n};\n\nContext.wrap = function(context) {\n  if (context instanceof Context) {\n    return context;\n  }\n  return new Context(new Stack(context));\n};\n\nContext.prototype.get = function(key) {\n  var ctx = this.stack, value;\n\n  while(ctx) {\n    if (ctx.isObject) {\n      value = ctx.head[key];\n      if (!(value === undefined)) {\n        return value;\n      }\n    }\n    ctx = ctx.tail;\n  }\n  return this.global ? this.global[key] : undefined;\n};\n\nContext.prototype.getPath = function(cur, down) {\n  var ctx = this.stack,\n      len = down.length;\n\n  if (cur && len === 0) return ctx.head;\n  ctx = ctx.head;\n  var i = 0;\n  while(ctx && i < len) {\n    ctx = ctx[down[i]];\n    i++;\n  }\n  return ctx;\n};\n\nContext.prototype.push = function(head, idx, len) {\n  return new Context(new Stack(head, this.stack, idx, len), this.global, this.blocks);\n};\n\nContext.prototype.rebase = function(head) {\n  return new Context(new Stack(head), this.global, this.blocks);\n};\n\nContext.prototype.current = function() {\n  return this.stack.head;\n};\n\nContext.prototype.getBlock = function(key, chk, ctx) {\n  if (typeof key === \"function\") {\n    key = key(chk, ctx).data;\n    chk.data = \"\";\n  }\n\n  var blocks = this.blocks;\n\n  if (!blocks) return;\n  var len = blocks.length, fn;\n  while (len--) {\n    fn = blocks[len][key];\n    if (fn) return fn;\n  }\n};\n\nContext.prototype.shiftBlocks = function(locals) {\n  var blocks = this.blocks,\n      newBlocks;\n\n  if (locals) {\n    if (!blocks) {\n      newBlocks = [locals];\n    } else {\n      newBlocks = blocks.concat([locals]);\n    }\n    return new Context(this.stack, this.global, newBlocks);\n  }\n  return this;\n};\n\nfunction Stack(head, tail, idx, len) {\n  this.tail = tail;\n  this.isObject = !dust.isArray(head) && head && typeof head === \"object\";\n  this.head = head;\n  this.index = idx;\n  this.of = len;\n}\n\nfunction Stub(callback) {\n  this.head = new Chunk(this);\n  this.callback = callback;\n  this.out = '';\n}\n\nStub.prototype.flush = function() {\n  var chunk = this.head;\n\n  while (chunk) {\n    if (chunk.flushable) {\n      this.out += chunk.data;\n    } else if (chunk.error) {\n      this.callback(chunk.error);\n      this.flush = function() {};\n      return;\n    } else {\n      return;\n    }\n    chunk = chunk.next;\n    this.head = chunk;\n  }\n  this.callback(null, this.out);\n};\n\nfunction Stream() {\n  this.head = new Chunk(this);\n}\n\nStream.prototype.flush = function() {\n  var chunk = this.head;\n\n  while(chunk) {\n    if (chunk.flushable) {\n      this.emit('data', chunk.data);\n    } else if (chunk.error) {\n      this.emit('error', chunk.error);\n      this.flush = function() {};\n      return;\n    } else {\n      return;\n    }\n    chunk = chunk.next;\n    this.head = chunk;\n  }\n  this.emit('end');\n};\n\nStream.prototype.emit = function(type, data) {\n  if (!this.events) return false;\n  var handler = this.events[type];\n  if (!handler) return false;\n  if (typeof handler == 'function') {\n    handler(data);\n  } else {\n    var listeners = handler.slice(0);\n    for (var i = 0, l = listeners.length; i < l; i++) {\n      listeners[i](data);\n    }\n  }\n};\n\nStream.prototype.on = function(type, callback) {\n  if (!this.events) {\n    this.events = {};\n  }\n  if (!this.events[type]) {\n    this.events[type] = callback;\n  } else if(typeof this.events[type] === 'function') {\n    this.events[type] = [this.events[type], callback];\n  } else {\n    this.events[type].push(callback);\n  }\n  return this;\n};\n\nStream.prototype.pipe = function(stream) {\n  this.on(\"data\", function(data) {\n    stream.write(data, \"utf8\");\n  }).on(\"end\", function() {\n    stream.end();\n  }).on(\"error\", function(err) {\n    stream.error(err);\n  });\n  return this;\n};\n\nfunction Chunk(root, next, taps) {\n  this.root = root;\n  this.next = next;\n  this.data = '';\n  this.flushable = false;\n  this.taps = taps;\n}\n\nChunk.prototype.write = function(data) {\n  var taps  = this.taps;\n\n  if (taps) {\n    data = taps.go(data);\n  }\n  this.data += data;\n  return this;\n};\n\nChunk.prototype.end = function(data) {\n  if (data) {\n    this.write(data);\n  }\n  this.flushable = true;\n  this.root.flush();\n  return this;\n};\n\nChunk.prototype.map = function(callback) {\n  var cursor = new Chunk(this.root, this.next, this.taps),\n      branch = new Chunk(this.root, cursor, this.taps);\n\n  this.next = branch;\n  this.flushable = true;\n  callback(branch);\n  return cursor;\n};\n\nChunk.prototype.tap = function(tap) {\n  var taps = this.taps;\n\n  if (taps) {\n    this.taps = taps.push(tap);\n  } else {\n    this.taps = new Tap(tap);\n  }\n  return this;\n};\n\nChunk.prototype.untap = function() {\n  this.taps = this.taps.tail;\n  return this;\n};\n\nChunk.prototype.render = function(body, context) {\n  return body(this, context);\n};\n\nChunk.prototype.reference = function(elem, context, auto, filters) {\n  if (typeof elem === \"function\") {\n    elem.isFunction = true;\n    // Changed the function calling to use apply with the current context to make sure \n    // that \"this\" is wat we expect it to be inside the function\n    elem = elem.apply(context.current(), [this, context, null, {auto: auto, filters: filters}]);\n    if (elem instanceof Chunk) {\n      return elem;\n    }\n  }\n  if (!dust.isEmpty(elem)) {\n    return this.write(dust.filter(elem, auto, filters));\n  } else {\n    return this;\n  }\n};\n\nChunk.prototype.section = function(elem, context, bodies, params) {\n  if (typeof elem === \"function\") {\n    elem = elem.apply(context.current(), [this, context, bodies, params]);\n    if (elem instanceof Chunk) {\n      return elem;\n    }\n  }\n\n  var body = bodies.block,\n      skip = bodies['else'];\n\n  if (params) {\n    context = context.push(params);\n  }\n\n  if (dust.isArray(elem)) {\n    if (body) {\n      var len = elem.length, chunk = this;\n      if (len > 0) {\n        context.stack.head['$len'] = len;\n        for (var i=0; i<len; i++) {\n          context.stack.head['$idx'] = i;\n          chunk = body(chunk, context.push(elem[i], i, len));\n        }\n        context.stack.head['$idx'] = undefined;\n        context.stack.head['$len'] = undefined;\n        return chunk;\n      } else if (skip) {\n        return skip(this, context);\n      }\n    }\n  } else if (elem === true) {\n    if (body) return body(this, context);\n  } else if (elem || elem === 0) {\n    if (body) {\n      context.stack.head['$idx'] = 0;\n      context.stack.head['$len'] = 1;\n      chunk = body(this, context.push(elem));\n      context.stack.head['$idx'] = undefined;\n      context.stack.head['$len'] = undefined;\n      return chunk;\n    }\n  } else if (skip) {\n    return skip(this, context);\n  }\n  return this;\n};\n\nChunk.prototype.exists = function(elem, context, bodies) {\n  var body = bodies.block,\n      skip = bodies['else'];\n\n  if (!dust.isEmpty(elem)) {\n    if (body) return body(this, context);\n  } else if (skip) {\n    return skip(this, context);\n  }\n  return this;\n};\n\nChunk.prototype.notexists = function(elem, context, bodies) {\n  var body = bodies.block,\n      skip = bodies['else'];\n\n  if (dust.isEmpty(elem)) {\n    if (body) return body(this, context);\n  } else if (skip) {\n    return skip(this, context);\n  }\n  return this;\n};\n\nChunk.prototype.block = function(elem, context, bodies) {\n  var body = bodies.block;\n\n  if (elem) {\n    body = elem;\n  }\n\n  if (body) {\n    return body(this, context);\n  }\n  return this;\n};\n\nChunk.prototype.partial = function(elem, context, params) {\n  var partialContext;\n  if (params){\n    //put the params context second to match what section does. {.} matches the current context without parameters\n    // start with an empty context\n    partialContext = dust.makeBase(context.global);\n    if (context.stack && context.stack.tail){\n      // grab the stack(tail) off of the previous context if we have it\n      partialContext.stack = context.stack.tail;\n    }\n    //put params on\n    partialContext = partialContext.push(params);\n    //reattach the head\n    partialContext = partialContext.push(context.stack.head);\n  } else {\n    partialContext = context;\n  }\n  if (typeof elem === \"function\") {\n    return this.capture(elem, partialContext, function(name, chunk) {\n      dust.load(name, chunk, partialContext).end();\n    });\n  }\n  return dust.load(elem, this, partialContext);\n};\n\nChunk.prototype.helper = function(name, context, bodies, params) {\n  return dust.helpers[name](this, context, bodies, params);\n};\n\nChunk.prototype.capture = function(body, context, callback) {\n  return this.map(function(chunk) {\n    var stub = new Stub(function(err, out) {\n      if (err) {\n        chunk.setError(err);\n      } else {\n        callback(out, chunk);\n      }\n    });\n    body(stub.head, context).end();\n  });\n};\n\nChunk.prototype.setError = function(err) {\n  this.error = err;\n  this.root.flush();\n  return this;\n};\n\nfunction Tap(head, tail) {\n  this.head = head;\n  this.tail = tail;\n}\n\nTap.prototype.push = function(tap) {\n  return new Tap(tap, this);\n};\n\nTap.prototype.go = function(value) {\n  var tap = this;\n\n  while(tap) {\n    value = tap.head(value);\n    tap = tap.tail;\n  }\n  return value;\n};\n\nvar HCHARS = new RegExp(/[&<>\\\"\\']/),\n    AMP    = /&/g,\n    LT     = /</g,\n    GT     = />/g,\n    QUOT   = /\\\"/g,\n    SQUOT  = /\\'/g;\n\ndust.escapeHtml = function(s) {\n  if (typeof s === \"string\") {\n    if (!HCHARS.test(s)) {\n      return s;\n    }\n    return s.replace(AMP,'&amp;').replace(LT,'&lt;').replace(GT,'&gt;').replace(QUOT,'&quot;').replace(SQUOT, '&#39;');\n  }\n  return s;\n};\n\nvar BS = /\\\\/g,\n    CR = /\\r/g,\n    LS = /\\u2028/g,\n    PS = /\\u2029/g,\n    NL = /\\n/g,\n    LF = /\\f/g,\n    SQ = /'/g,\n    DQ = /\"/g,\n    TB = /\\t/g;\n\ndust.escapeJs = function(s) {\n  if (typeof s === \"string\") {\n    return s\n      .replace(BS, '\\\\\\\\')\n      .replace(DQ, '\\\\\"')\n      .replace(SQ, \"\\\\'\")\n      .replace(CR, '\\\\r')\n      .replace(LS, '\\\\u2028')\n      .replace(PS, '\\\\u2029')\n      .replace(NL, '\\\\n')\n      .replace(LF, '\\\\f')\n      .replace(TB, \"\\\\t\");\n  }\n  return s;\n};\n\n})(dust);\n\nif (typeof exports !== \"undefined\") {\n  //TODO: Remove the helpers from dust core in the next release.\n  dust.helpers = require(\"./dust-helpers\").helpers;\n  if (typeof process !== \"undefined\") {\n      require('./server')(dust);\n  }\n  module.exports = dust;\n}\n"]],"start1":0,"start2":0,"length1":0,"length2":13319}]],"length":13319}
