{"ts":1356729374236,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"\n/*!\n * consolidate\n * Copyright(c) 2012 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n * \n * Engines which do not support caching of their file contents\n * should use the `read()` function defined in consolidate.js\n * On top of this, when an engine compiles to a `Function`,\n * these functions should either be cached within consolidate.js\n * or the engine itself via `options.cache`. This will allow\n * users and frameworks to pass `options.cache = true` for\n * `NODE_ENV=production`, however edit the file(s) without\n * re-loading the application in development.\n */\n\n/**\n * Module dependencies.\n */\n\nvar fs = require('fs');\n\n/**\n * Require cache.\n */\n\nvar cache = {};\n\n/**\n * Require cache.\n */\n\nvar requires = {};\n\n/**\n * Clear the cache.\n *\n * @api public\n */\n\nexports.clearCache = function(){\n  cache = {};\n};\n\n/**\n * Read `path` with `options` with\n * callback `(err, str)`. When `options.cache`\n * is true the template string will be cached.\n *\n * @param {String} options\n * @param {Function} fn\n * @api private\n */\n\nfunction read(path, options, fn) {\n  var str = cache[path];\n\n  // cached (only if cached is a string and not a compiled template function)\n  if (options.cache && str && typeof str === 'string') return fn(null, str);\n\n  // read\n  fs.readFile(path, 'utf8', function(err, str){\n    if (err) return fn(err);\n    if (options.cache) cache[path] = str;\n    fn(null, str);\n  });\n}\n\n/**\n * Jade support.\n */\n\nexports.jade = function(path, options, fn){\n  var engine = requires.jade || (requires.jade = require('jade'));\n  engine.renderFile(path, options, fn);\n};\n\n/**\n * Dust support.\n */\n\nexports.dust = function(path, options, fn){\n  var engine = requires.dust;\n\n  if (!engine) {\n    try {\n      requires.dust = require('dust');\n    } catch (err) {\n      requires.dust = require('dustjs-linkedin');\n    }\n    engine = requires.dust;\n    engine.onLoad = function(path, callback) { read(path, options, callback); }\n  }\n\n  var tmpl = cache[path];\n\n  // try cache (only if cached is a compiled template function and not a string)\n  if (options.cache && tmpl && 'function' == typeof tmpl) {\n    tmpl(options, fn);\n  } else {\n    read(path, options, function(err, str) {\n      if (err) return fn(err);\n      try {\n        options.filename = path;\n        tmpl = engine.compileFn(str);\n\n        if (options.cache) cache[path] = tmpl;\n        else engine.cache = {};\n\n        tmpl(options, fn);\n      } catch (err) {\n        fn(err);\n      }\n    });\n  }\n};\n\n/**\n * Swig support.\n */\n\nexports.swig = function(path, options, fn){\n  var engine = requires.swig || (requires.swig = require('swig'));\n  read(path, options, function(err, str){\n    if (err) return fn(err);\n    try {\n      options.filename = path;\n      var tmpl = engine.compile(str, options);\n      fn(null, tmpl(options));\n    } catch (err) {\n      fn(err);\n    }\n  });\n};\n\n/**\n * Liquor support,\n */\n\nexports.liquor = function(path, options, fn){\n  var engine = requires.liquor || (requires.liquor = require('liquor'));\n  read(path, options, function(err, str){\n    if (err) return fn(err);\n    try {\n      options.filename = path;\n      var tmpl = engine.compile(str, options);\n      fn(null, tmpl(options));\n    } catch (err) {\n      fn(err);\n    }\n  });\n};\n\n/**\n * EJS support.\n */\n\nexports.ejs = function(path, options, fn){\n  var engine = requires.ejs || (requires.ejs = require('ejs'));\n  read(path, options, function(err, str){\n    if (err) return fn(err);\n    try {\n      options.filename = path;\n      var tmpl = engine.compile(str, options);\n      fn(null, tmpl(options));\n    } catch (err) {\n      fn(err);\n    }\n  });\n};\n\n/**\n * Eco support.\n */\n\nexports.eco = function(path, options, fn){\n  var engine = requires.eco || (requires.eco = require('eco'));\n  read(path, options, function(err, str){\n    if (err) return fn(err);\n    try {\n      options.filename = path;\n      fn(null, engine.render(str, options));\n    } catch (err) {\n      fn(err);\n    }\n  });\n};\n\n/**\n * Jazz support.\n */\n\nexports.jazz = function(path, options, fn){\n  var engine = requires.jazz || (requires.jazz = require('jazz'));\n  read(path, options, function(err, str){\n    if (err) return fn(err);\n    try {\n      options.filename = path;\n      var tmpl = engine.compile(str, options);\n      tmpl.eval(options, function(str){\n        fn(null, str);\n      });\n    } catch (err) {\n      fn(err);\n    }\n  });\n};\n\n/**\n * JQTPL support.\n */\n\nexports.jqtpl = function(path, options, fn){\n  var engine = requires.jqtpl || (requires.jqtpl = require('jqtpl'));\n  read(path, options, function(err, str){\n    if (err) return fn(err);\n    try {\n      options.filename = path;\n      engine.template(path, str);\n      fn(null, engine.tmpl(path, options));\n    } catch (err) {\n      fn(err);\n    }\n  });\n};\n\n/**\n * Haml support.\n */\n\nexports.haml = function(path, options, fn){\n  var engine = requires.hamljs || (requires.hamljs = require('hamljs'));\n  read(path, options, function(err, str){\n    if (err) return fn(err);\n    try {\n      options.filename = path;\n      options.locals = options;\n      fn(null, engine.render(str, options).trimLeft());\n    } catch (err) {\n      fn(err);\n    }\n  });\n};\n\n/**\n * Whiskers support.\n */\n\nexports.whiskers = function(path, options, fn){\n  var engine = requires.whiskers || (requires.whiskers = require('whiskers'));\n  engine.__express(path, options, fn);\n};\n\n/**\n * Coffee-HAML support.\n */\n\nexports['haml-coffee'] = function(path, options, fn){\n  var engine = requires.HAMLCoffee || (requires.HAMLCoffee = require('haml-coffee'));\n  read(path, options, function(err, str){\n    if (err) return fn(err);\n    try {\n      var tmpl = engine.compile(str, options);\n      fn(null, tmpl(options));\n    } catch (err) {\n      fn(err);\n    }\n  });\n};\n\n/**\n * Hogan support.\n */\n\nexports.hogan = function(path, options, fn){\n  var engine = requires.hogan || (requires.hogan = require('hogan.js'));\n  read(path, options, function(err, str){\n    if (err) return fn(err);\n    try {\n      var tmpl = engine.compile(str, options);\n      fn(null, tmpl.render(options));\n    } catch (err) {\n      fn(err);\n    }\n  });\n};\n\n/**\n * Handlebars support.\n */\n\nexports.handlebars = function(path, options, fn) {\n  var engine = requires.handlebars || (requires.handlebars = require('handlebars'));\n  read(path, options, function(err, str){\n    if (err) return fn(err);\n    try {\n      options.filename = path;\n      var tmpl = engine.compile(str, options);\n      fn(null, tmpl(options));\n    } catch (err) {\n      fn(err);\n    }\n  });\n}\n\n/**\n * Underscore support.\n */\n\nexports.underscore = function(path, options, fn) {\n  var engine = requires.underscore || (requires.underscore = require('underscore'));\n  read(path, options, function(err, str){\n    if (err) return fn(err);\n    try {\n      options.filename = path;\n      var tmpl = engine.template(str, null, options);\n      fn(null, tmpl(options).replace(/\\n$/, ''));\n    } catch (err) {\n      fn(err);\n    }\n  });\n}\n\n\n/**\n * QEJS support.\n */\n\nexports.qejs = function (path, options, fn) {\n  try {\n    var engine = requires.qejs || (requires.qejs = require('qejs'));\n    engine.renderFile(path, options).then(function (result) {\n        fn(null, result);\n    }, function (err) {\n        fn(err);\n    }).end();\n  } catch (err) {\n    fn(err);\n  }\n};\n\n\n/**\n * Walrus support.\n */\n\nexports.walrus = function (path, options, fn) {\n  var engine = requires.walrus || (requires.walrus = require('walrus'));\n  var tmpl = cache[path];\n\n  // try cache (only if cached is a compiled template function and not a string)\n  if (options.cache && tmpl && 'function' == typeof tmpl) {\n    tmpl(options, fn);\n  } else {\n    read(path, options, function(err, str){\n      if (err) return fn(err);\n      try {\n        var tmpl = engine.parse(str);\n        fn(null, tmpl.compile(options));\n      } catch (err) {\n        fn(err);\n      }\n    });\n  }\n};\n\n/**\n * Mustache support.\n */\n\nexports.mustache = function(path, options, fn) {\n  var engine = requires.mustache || (requires.mustache = require('mustache'));\n  read(path, options, function(err, str){\n    if (err) return fn(err);\n    try {\n      options.filename = path;\n      fn(null, engine.to_html(str, options));\n    } catch (err) {\n      fn(err);\n    }\n  });\n};\n\n/**\n * doT support.\n */\n\nexports.dot = function(path, options, fn) {\n  var engine = requires.dot || (requires.dot = require('dot'));\n  var tmpl = cache[path];\n\n  // try cache (only if cached is a compiled template function and not a string)\n  if (options.cache && tmpl && 'function' == typeof tmpl) {\n    try {\n      var html = tmpl(options);\n      fn(null, html);\n    } catch (err) {\n      fn(err);\n    }\n  } else {\n    read(path, options, function(err, str) {\n      if (err) return fn(err);\n      try {\n        var tmpl = engine.template(str);\n        cache[path] = tmpl;\n        fn(null, tmpl(options));\n      } catch (err) {\n        fn(err);\n      }\n    });\n  }\n};\n"]],"start1":0,"start2":0,"length1":0,"length2":8887}]],"length":8887}
